### 缓存雪崩、缓存穿透和读写一致

#### 一、前言

我们为什么要用缓存：

**1. 提高性能**

缓存查询速度比数据库查询快的多，缓存是存在内存里的，数据库数据是存在硬盘的。
**2. 提高并发能力**

缓存承担了部分请求，减轻服务器的负担，支持更高的并发。

使用缓存虽然可以帮助我们提高性能，但是我们也应该避免乱用缓存带来一些意想不到的后果。

#### 二、缓存雪崩
**2.1 什么是缓存雪崩**

&emsp;&emsp;我们都知道Redis是使用内存来存储数据的，内存由于非常昂贵，我们不可能把APP所有数据都存储在内存里。Redis支持对缓存数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。如果缓存设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存全部失效，全部请求直接到数据库中去查询。这就是缓存雪崩。缓存雪崩如果发生了，很可能就把我们的数据库搞垮，导致整个APP崩溃瘫痪。

**2.2 如何解决缓存雪崩**

对于“对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。”这种情况，解决方案：

- 在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时期过渡。

对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：

- 事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。

- 事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)

- 事发后：Redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

#### 三、缓存穿透
**3.1 什么是缓存穿透**

假设我们有一张数据表，主键ID都是从1开始递增的,但是可能有黑客想把我们的数据库搞垮，每次请求的ID都是负数。这就会导致缓存就没用了，请求全部都找数据库去了，但数据库也没有这个值啊，所以每次都返回空出去，这就是缓存穿透。缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。缓存穿透如果发生了，也可能把我们的数据库搞垮，导致整个服务瘫痪！

**3.2 如何解决缓存穿透**

解决缓存穿透的方案：

- 由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！
- 当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个较短的过期时间。

#### 四、缓存与数据库读写不一致

**4.1 对于读操作**

一般我们对读操作的时候有这么一个固定的套路：

- 如果我们的数据在缓存里边有，那么就直接取缓存的。
- 如果缓存里没有我们想要的数据，我们会先去查询数据库，然后将数据库查出来的数据写到缓存中。
- 最后将数据返回给请求

**4.2 什么是缓存与数据库双写一致问题**

如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是，当我们要更新时候呢？各种情况很可能就造成数据库和缓存的数据不一致了。从理论上说，只要我们设置了键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生。

**4.3 对于更新操作**

一般来说，执行更新操作时，我们会有两种选择：

- 先操作数据库，再操作缓存
- 先操作缓存，再操作数据库

首先，要明确的是，无论我们选择哪个，我们都希望这两个操作要么同时成功，要么同时失败。所以，这会演变成一个分布式事务的问题。

所以，如果原子性被破坏了，可能会有以下的情况：

- 操作数据库成功了，操作缓存失败了。

- 操作缓存成功了，操作数据库失败了。

**4.3.1 操作缓存**

操作缓存也有两种方案：

- 更新缓存

- 删除缓存

一般我们都是采取删除缓存缓存策略的，原因如下：

- 高并发环境下，无论是先操作数据库还是后操作数据库而言，如果加上更新缓存，那就更加容易导致数据库与缓存数据不一致问题。(删除缓存直接和简单很多)

- 如果每次更新了数据库，都要更新缓存【这里指的是频繁更新的场景，这会耗费一定的性能】，倒不如直接删除掉。等再次读取时，缓存里没有，那我到数据库找，在数据库找到再写到缓存里边(体现懒加载)
  基于这两点，对于缓存在更新时而言，都是建议执行删除操作！
  
**4.3.2先更新数据库，再删除缓存**
正常的情况是这样的：

- 先操作数据库，成功；

- 再删除缓存，也成功；

如果原子性被破坏了：

- 第一步成功(操作数据库)，第二步失败(删除缓存)，会导致数据库里是新数据，而缓存里是旧数据。

- 如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。

如果在高并发的场景下，出现数据库与缓存数据不一致的概率特别低，也不是没有：

- 缓存刚好失效

- 线程A查询数据库，得一个旧值

- 线程B将新值写入数据库

- 线程B删除缓存

- 线程A将查到的旧值写入缓存

删除缓存失败的解决思路：

- 将需要删除的key发送到消息队列中

- 自己消费消息，获得需要删除的key

- 不断重试删除操作，直到成功

**4.3.3先删除缓存，再更新数据库**

正常情况是这样的：

- 先删除缓存，成功；

- 再更新数据库，也成功；

如果原子性被破坏了：

- 第一步成功(删除缓存)，第二步失败(更新数据库)，数据库和缓存的数据还是一致的。

- 如果第一步(删除缓存)就失败了，我们可以直接返回错误(Exception)，数据库和缓存的数据还是一致的。

看起来是很美好，但是我们在并发场景下分析一下，就知道还是有问题的了：

- 线程A删除了缓存

- 线程B查询，发现缓存已不存在

- 线程B去数据库查询得到旧值

- 线程B将旧值写入缓存

- 线程A将新值写入数据库

所以也会导致数据库和缓存不一致的问题。

**4.4对比两种策略**

两种策略各自有优缺点：

- 先删除缓存，再更新数据库：在高并发下表现不如意，在原子性被破坏时表现优异

- 先更新数据库，再删除缓存(Cache Aside Pattern设计模式)：在高并发下表现优异，在原子性被破坏时表现不如意








